{
  "name": "barrage",
  "version": "0.0.4",
  "description": "Extensions to streams (as a mixin)",
  "keywords": [],
  "dependencies": {
    "promise": "~3.2.0",
    "readable-stream": "~1.0.2"
  },
  "devDependencies": {
    "mocha": "*"
  },
  "optionalDependencies": {
    "readable-stream": "~1.0.2"
  },
  "scripts": {
    "test": "mocha -R spec"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/ForbesLindesay/barrage.git"
  },
  "author": {
    "name": "ForbesLindesay"
  },
  "license": "MIT",
  "readme": "# barrage\r\n\r\nExtensions to streams (as a mixin)\r\n\r\n[![Build Status](https://travis-ci.org/ForbesLindesay/barrage.png?branch=master)](https://travis-ci.org/ForbesLindesay/barrage)\r\n[![Dependency Status](https://gemnasium.com/ForbesLindesay/barrage.png)](https://gemnasium.com/ForbesLindesay/barrage)\r\n[![NPM version](https://badge.fury.io/js/barrage.png)](http://badge.fury.io/js/barrage)\r\n\r\n## Installation\r\n\r\n    npm install barrage\r\n\r\n## API\r\n\r\nThe main export is `barrage(stream)` which adds the extension methods as helper methods to an existing stream.  If used on node v0.8 it will wrap the stream using `readable-stream`.\r\n\r\nIt also exports the same API as the `v0.10` stream module with Readable, Writable, Duplex, Transform and PassThrough (except that each one is extended with the `barrage` extensions mixin).\r\n\r\nNote that no native modules are affected, all the extensions are safe to use with other non barrage code.\r\n\r\nThe following extensions are currently added to Barrage Streams:\r\n\r\n### barrage.syphon(stream, [options])\r\n\r\nThis is exactly like the built in `source.pipe(destination, [options])` except that it also forwards any errors emitted by `source` to the `destination`.  When your streams represent transformations, that is usually much more useful than the built in `.pipe`.\r\n\r\n### barrage.buffer([encoding], callback)\r\n\r\nWhen the barrage is a readable stream, this method buffers the results and handles errors, resulting in a node.js style `callback` API.  If there is no `encoding` parameter, the callback is called with an `Array` for the result.  If encoding is `'buffer'` then the callback is called with a single `Buffer` for the result.  If any other string is passed as `encoding`, the `encoding` parameter is passed on to `buffer.toString(encoding)` and the result is therefore a `String`\r\n\r\nIf the callback parameter is absent, a [Promises/A+](http://promises-aplus.github.io/promises-spec/) promise is returned instead.\r\n\r\n### barrage.wait(callback)\r\n\r\nThis works like `barrage.buffer`, except that it does not buffer the result.  It will wait for an `end` or `finish` event and then call the callback.  If an error event is fired, the callback is called with that error. The callback is only ever called once.\r\n\r\nIf the callback parameter is absent, a [Promises/A+](http://promises-aplus.github.io/promises-spec/) promise is returned instead.\r\n\r\n## License\r\n\r\n  MIT",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/ForbesLindesay/barrage/issues"
  },
  "_id": "barrage@0.0.4",
  "dist": {
    "shasum": "d0e4464214ab9a2a00b377eabcc5626807128a00"
  },
  "_from": "barrage@0.0.4",
  "_resolved": "https://registry.npmjs.org/barrage/-/barrage-0.0.4.tgz"
}
